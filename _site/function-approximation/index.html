<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=4347d9b846f2cebdc47e657f7c3c9e451d3ad96a">
    <!-- Mathjax Support -->
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Function Approximation | alexandervandekleut.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Function Approximation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Function Approximation in Tensorflow&#182;Function approximation is a technique for learning a function $y$ by providing an approximation for the function, $\hat{y}$. A differentiable function approximator is a function whose output is a differentiable function of its inputs. There are many differentiable function approximators. You have have heard of linear regressions and logistic regressions. We can abstractly define a function approximator as a set of parameters $\theta$. For example, in a simple quadratic regression of the form $$ \hat{y} = a x^2 + b x + c $$ we would have $\theta = \left[ a, b, c \right]$. Gradient Descent and Loss Functions&#182;When a function approximator is differentiable, we have an additional tool at our disposal: gradient descent. Gradient descent is a tool for optimizing any differentiable function. The gradient of a function $f$ with respect to some parameters $\theta$ is denoted $\nabla_\theta f$, and is a vector of partial derivatives of $f$ with respect to each variable in $\theta$. For example, $\nabla_\theta \hat{y}$ would be $$ \nabla_\theta \hat{y} = \begin{bmatrix} x^2 \\ x \\ 1 \end{bmatrix} $$ Imagine some dataset $(X, Y)$ that we are interested in modelling, and we have a suspicion that the relationship between $X$ and $Y$ is quadratic. Then we can use a function like the one described above ($ax^2 + bx + c$) to try to model the dataset. Given a data point $(x, y)$, we want the difference between our functions output $\hat{y}$ and the true value $y$ to be small. We use the squared-error to measure this difference: $\left(y - \hat{y} \right)^2$. If our function approximator $\theta$ minimizes the average squared error over all data points, then we say our function successfully models the data. We define a loss function with respect to the model parameters $\theta$ that we want to minimize. In accordance with our description above, we get: $$ L(\theta) = \frac{1}{N} \sum_{(x, y) \in X \times Y} \left(\hat{y} - y \right)^2 $$ where $N$ is the size of the dataset and $\hat{y} = ax^2 + bx + c $. We can iteratively modify our paramaters $\theta$ so as to minimize this loss function. If we take the gradient of the loss function with respect to $\theta$ and we subtract that from $\theta$, then we get new values for $\theta$ such that the value $L(\theta)$ is smaller. This gives us gradient descent: $$ \theta \gets \theta + \alpha \nabla_\theta L(\theta) $$ where $\alpha$ is a factor called the learning rate that determines how much we change the network parameters with each application of gradient descent. We perform gradient descent for a given number of epochs until we are satisfied that our function does a good approximation. In this case, we can easily analytically compute this: $$ \nabla_\theta L(\theta) = \frac{1}{N} \sum_{(x, y) \in (X, Y)} 2(\hat{y} - y) \nabla_{\theta} \hat{y} $$ where $\nabla_\theta \hat{y}$ is as descibed above. In&nbsp;[1]: import numpy as np import seaborn as sns import pandas as pd import gym import tensorflow as tf sns.set() In&nbsp;[2]: def plot(X, Y, Y_hat): data = pd.DataFrame({&quot;X&quot;:X, &quot;Y&quot;:Y, &quot;Y_hat&quot;:Y_hat}) sns.scatterplot(x=&quot;X&quot;, y=&quot;Y&quot;, data=data) sns.lineplot(x=&quot;X&quot;, y=&quot;Y_hat&quot;, data=data) In&nbsp;[3]: N = 50 a, b, c = 2, -1, 4 X = np.linspace(-1, 1, N) Y = a*X**2 + b*X + c + np.random.randn(N)*0.1 In&nbsp;[4]: theta = np.random.rand(3) # a, b, c estimates Y_hat = theta[0]*X**2 + theta[1]*X + theta[2] In&nbsp;[5]: plot(X, Y, Y_hat) In&nbsp;[17]: def learn(X, Y, theta, alpha=1e-1, epochs=100): for e in range(epochs): Y_hat = theta[0]*(X**2) + theta[1]*X + theta[2] nabla_theta_y_hat = np.array([ X**2, X, np.ones(N) ]) nabla_theta_L = np.mean(2*(Y_hat - Y)*nabla_theta_y_hat, axis=1) theta = theta - alpha*nabla_theta_L return theta In&nbsp;[7]: learned_theta = learn(X, Y, theta) Y_hat = learned_theta[0]*X**2 + learned_theta[1]*X + learned_theta[2] In&nbsp;[8]: plot(X, Y, Y_hat) Tensorflow and Autodifferentiation&#182;It can be extremely cumbersome to manually compute the derivative of our functions. It becomes much more complex when our functions are highly composed, where we combine the results of many intermediate calculations to produce our result. Instead, we can rely on libraries that provide autodifferentiation. There are many approaches to autodifferentiation, with the notion of a &#39;gradient tape&#39; being used in tensorflow 2 and pytorch. Most guides, resources and open-source implementations that you will find today are built using tensorflow, a python library that allows us to define complex computation graphs with built-in differentiation. Tensorflow is preferred for many reasons (though the gap may be closing), but using computation graphs can feel weird to a new user. Tensorflow has extensive documentation that I suggest you spend some time reading, since my goal is not to reproduce the tensorflow guide here. I assume you have a basic understanding of how tensorflow works. Let us first demonstrate the above regression problem using tensorflow before moving into more complex territory. In&nbsp;[9]: N = 50 a, b, c = 2, -1, 4 X = np.linspace(-1, 1, N) Y = a*X**2 + b*X + c + np.random.randn(N)*0.1 In&nbsp;[10]: X_ph = tf.placeholder(shape=(50,), dtype=tf.float32) # a placeholder for values, that we will later feed X into theta = tf.get_variable(&quot;theta&quot;, initializer=tf.random_normal(shape=(3,))) # our parameters Y_hat = theta[0]*(X_ph**2) + theta[1]*X_ph + theta[2] # our prediction WARNING:tensorflow:From /anaconda3/envs/rl-lessons/lib/python3.6/site-packages/tensorflow/python/framework/op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version. Instructions for updating: Colocations handled automatically by placer. In&nbsp;[11]: sess = tf.Session() # used to give tensors in the computation graph values sess.run(tf.global_variables_initializer()) # initialize defined ops and variables Y_hat_run = sess.run(Y_hat, feed_dict = { X_ph: X }) # get initial predictions In&nbsp;[12]: plot(X, Y, Y_hat_run) In&nbsp;[13]: L_theta = tf.reduce_mean((Y - Y_hat)**2) # same loss as before alpha = 1e-1 # learning rate optimizer = tf.train.GradientDescentOptimizer(alpha).minimize(L_theta) # autodifferentiation! In&nbsp;[14]: epochs = 100 for e in range(epochs): sess.run(optimizer, feed_dict = { X_ph:X }) In&nbsp;[15]: Y_hat_run = sess.run(Y_hat, feed_dict = { X_ph: X }) In&nbsp;[16]: plot(X, Y, Y_hat_run)" />
<meta property="og:description" content="Function Approximation in Tensorflow&#182;Function approximation is a technique for learning a function $y$ by providing an approximation for the function, $\hat{y}$. A differentiable function approximator is a function whose output is a differentiable function of its inputs. There are many differentiable function approximators. You have have heard of linear regressions and logistic regressions. We can abstractly define a function approximator as a set of parameters $\theta$. For example, in a simple quadratic regression of the form $$ \hat{y} = a x^2 + b x + c $$ we would have $\theta = \left[ a, b, c \right]$. Gradient Descent and Loss Functions&#182;When a function approximator is differentiable, we have an additional tool at our disposal: gradient descent. Gradient descent is a tool for optimizing any differentiable function. The gradient of a function $f$ with respect to some parameters $\theta$ is denoted $\nabla_\theta f$, and is a vector of partial derivatives of $f$ with respect to each variable in $\theta$. For example, $\nabla_\theta \hat{y}$ would be $$ \nabla_\theta \hat{y} = \begin{bmatrix} x^2 \\ x \\ 1 \end{bmatrix} $$ Imagine some dataset $(X, Y)$ that we are interested in modelling, and we have a suspicion that the relationship between $X$ and $Y$ is quadratic. Then we can use a function like the one described above ($ax^2 + bx + c$) to try to model the dataset. Given a data point $(x, y)$, we want the difference between our functions output $\hat{y}$ and the true value $y$ to be small. We use the squared-error to measure this difference: $\left(y - \hat{y} \right)^2$. If our function approximator $\theta$ minimizes the average squared error over all data points, then we say our function successfully models the data. We define a loss function with respect to the model parameters $\theta$ that we want to minimize. In accordance with our description above, we get: $$ L(\theta) = \frac{1}{N} \sum_{(x, y) \in X \times Y} \left(\hat{y} - y \right)^2 $$ where $N$ is the size of the dataset and $\hat{y} = ax^2 + bx + c $. We can iteratively modify our paramaters $\theta$ so as to minimize this loss function. If we take the gradient of the loss function with respect to $\theta$ and we subtract that from $\theta$, then we get new values for $\theta$ such that the value $L(\theta)$ is smaller. This gives us gradient descent: $$ \theta \gets \theta + \alpha \nabla_\theta L(\theta) $$ where $\alpha$ is a factor called the learning rate that determines how much we change the network parameters with each application of gradient descent. We perform gradient descent for a given number of epochs until we are satisfied that our function does a good approximation. In this case, we can easily analytically compute this: $$ \nabla_\theta L(\theta) = \frac{1}{N} \sum_{(x, y) \in (X, Y)} 2(\hat{y} - y) \nabla_{\theta} \hat{y} $$ where $\nabla_\theta \hat{y}$ is as descibed above. In&nbsp;[1]: import numpy as np import seaborn as sns import pandas as pd import gym import tensorflow as tf sns.set() In&nbsp;[2]: def plot(X, Y, Y_hat): data = pd.DataFrame({&quot;X&quot;:X, &quot;Y&quot;:Y, &quot;Y_hat&quot;:Y_hat}) sns.scatterplot(x=&quot;X&quot;, y=&quot;Y&quot;, data=data) sns.lineplot(x=&quot;X&quot;, y=&quot;Y_hat&quot;, data=data) In&nbsp;[3]: N = 50 a, b, c = 2, -1, 4 X = np.linspace(-1, 1, N) Y = a*X**2 + b*X + c + np.random.randn(N)*0.1 In&nbsp;[4]: theta = np.random.rand(3) # a, b, c estimates Y_hat = theta[0]*X**2 + theta[1]*X + theta[2] In&nbsp;[5]: plot(X, Y, Y_hat) In&nbsp;[17]: def learn(X, Y, theta, alpha=1e-1, epochs=100): for e in range(epochs): Y_hat = theta[0]*(X**2) + theta[1]*X + theta[2] nabla_theta_y_hat = np.array([ X**2, X, np.ones(N) ]) nabla_theta_L = np.mean(2*(Y_hat - Y)*nabla_theta_y_hat, axis=1) theta = theta - alpha*nabla_theta_L return theta In&nbsp;[7]: learned_theta = learn(X, Y, theta) Y_hat = learned_theta[0]*X**2 + learned_theta[1]*X + learned_theta[2] In&nbsp;[8]: plot(X, Y, Y_hat) Tensorflow and Autodifferentiation&#182;It can be extremely cumbersome to manually compute the derivative of our functions. It becomes much more complex when our functions are highly composed, where we combine the results of many intermediate calculations to produce our result. Instead, we can rely on libraries that provide autodifferentiation. There are many approaches to autodifferentiation, with the notion of a &#39;gradient tape&#39; being used in tensorflow 2 and pytorch. Most guides, resources and open-source implementations that you will find today are built using tensorflow, a python library that allows us to define complex computation graphs with built-in differentiation. Tensorflow is preferred for many reasons (though the gap may be closing), but using computation graphs can feel weird to a new user. Tensorflow has extensive documentation that I suggest you spend some time reading, since my goal is not to reproduce the tensorflow guide here. I assume you have a basic understanding of how tensorflow works. Let us first demonstrate the above regression problem using tensorflow before moving into more complex territory. In&nbsp;[9]: N = 50 a, b, c = 2, -1, 4 X = np.linspace(-1, 1, N) Y = a*X**2 + b*X + c + np.random.randn(N)*0.1 In&nbsp;[10]: X_ph = tf.placeholder(shape=(50,), dtype=tf.float32) # a placeholder for values, that we will later feed X into theta = tf.get_variable(&quot;theta&quot;, initializer=tf.random_normal(shape=(3,))) # our parameters Y_hat = theta[0]*(X_ph**2) + theta[1]*X_ph + theta[2] # our prediction WARNING:tensorflow:From /anaconda3/envs/rl-lessons/lib/python3.6/site-packages/tensorflow/python/framework/op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version. Instructions for updating: Colocations handled automatically by placer. In&nbsp;[11]: sess = tf.Session() # used to give tensors in the computation graph values sess.run(tf.global_variables_initializer()) # initialize defined ops and variables Y_hat_run = sess.run(Y_hat, feed_dict = { X_ph: X }) # get initial predictions In&nbsp;[12]: plot(X, Y, Y_hat_run) In&nbsp;[13]: L_theta = tf.reduce_mean((Y - Y_hat)**2) # same loss as before alpha = 1e-1 # learning rate optimizer = tf.train.GradientDescentOptimizer(alpha).minimize(L_theta) # autodifferentiation! In&nbsp;[14]: epochs = 100 for e in range(epochs): sess.run(optimizer, feed_dict = { X_ph:X }) In&nbsp;[15]: Y_hat_run = sess.run(Y_hat, feed_dict = { X_ph: X }) In&nbsp;[16]: plot(X, Y, Y_hat_run)" />
<link rel="canonical" href="http://localhost:4000/function-approximation/" />
<meta property="og:url" content="http://localhost:4000/function-approximation/" />
<meta property="og:site_name" content="alexandervandekleut.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-21T00:00:00-04:00" />
<script type="application/ld+json">
{"description":"Function Approximation in Tensorflow&#182;Function approximation is a technique for learning a function $y$ by providing an approximation for the function, $\\hat{y}$. A differentiable function approximator is a function whose output is a differentiable function of its inputs. There are many differentiable function approximators. You have have heard of linear regressions and logistic regressions. We can abstractly define a function approximator as a set of parameters $\\theta$. For example, in a simple quadratic regression of the form $$ \\hat{y} = a x^2 + b x + c $$ we would have $\\theta = \\left[ a, b, c \\right]$. Gradient Descent and Loss Functions&#182;When a function approximator is differentiable, we have an additional tool at our disposal: gradient descent. Gradient descent is a tool for optimizing any differentiable function. The gradient of a function $f$ with respect to some parameters $\\theta$ is denoted $\\nabla_\\theta f$, and is a vector of partial derivatives of $f$ with respect to each variable in $\\theta$. For example, $\\nabla_\\theta \\hat{y}$ would be $$ \\nabla_\\theta \\hat{y} = \\begin{bmatrix} x^2 \\\\ x \\\\ 1 \\end{bmatrix} $$ Imagine some dataset $(X, Y)$ that we are interested in modelling, and we have a suspicion that the relationship between $X$ and $Y$ is quadratic. Then we can use a function like the one described above ($ax^2 + bx + c$) to try to model the dataset. Given a data point $(x, y)$, we want the difference between our functions output $\\hat{y}$ and the true value $y$ to be small. We use the squared-error to measure this difference: $\\left(y - \\hat{y} \\right)^2$. If our function approximator $\\theta$ minimizes the average squared error over all data points, then we say our function successfully models the data. We define a loss function with respect to the model parameters $\\theta$ that we want to minimize. In accordance with our description above, we get: $$ L(\\theta) = \\frac{1}{N} \\sum_{(x, y) \\in X \\times Y} \\left(\\hat{y} - y \\right)^2 $$ where $N$ is the size of the dataset and $\\hat{y} = ax^2 + bx + c $. We can iteratively modify our paramaters $\\theta$ so as to minimize this loss function. If we take the gradient of the loss function with respect to $\\theta$ and we subtract that from $\\theta$, then we get new values for $\\theta$ such that the value $L(\\theta)$ is smaller. This gives us gradient descent: $$ \\theta \\gets \\theta + \\alpha \\nabla_\\theta L(\\theta) $$ where $\\alpha$ is a factor called the learning rate that determines how much we change the network parameters with each application of gradient descent. We perform gradient descent for a given number of epochs until we are satisfied that our function does a good approximation. In this case, we can easily analytically compute this: $$ \\nabla_\\theta L(\\theta) = \\frac{1}{N} \\sum_{(x, y) \\in (X, Y)} 2(\\hat{y} - y) \\nabla_{\\theta} \\hat{y} $$ where $\\nabla_\\theta \\hat{y}$ is as descibed above. In&nbsp;[1]: import numpy as np import seaborn as sns import pandas as pd import gym import tensorflow as tf sns.set() In&nbsp;[2]: def plot(X, Y, Y_hat): data = pd.DataFrame({&quot;X&quot;:X, &quot;Y&quot;:Y, &quot;Y_hat&quot;:Y_hat}) sns.scatterplot(x=&quot;X&quot;, y=&quot;Y&quot;, data=data) sns.lineplot(x=&quot;X&quot;, y=&quot;Y_hat&quot;, data=data) In&nbsp;[3]: N = 50 a, b, c = 2, -1, 4 X = np.linspace(-1, 1, N) Y = a*X**2 + b*X + c + np.random.randn(N)*0.1 In&nbsp;[4]: theta = np.random.rand(3) # a, b, c estimates Y_hat = theta[0]*X**2 + theta[1]*X + theta[2] In&nbsp;[5]: plot(X, Y, Y_hat) In&nbsp;[17]: def learn(X, Y, theta, alpha=1e-1, epochs=100): for e in range(epochs): Y_hat = theta[0]*(X**2) + theta[1]*X + theta[2] nabla_theta_y_hat = np.array([ X**2, X, np.ones(N) ]) nabla_theta_L = np.mean(2*(Y_hat - Y)*nabla_theta_y_hat, axis=1) theta = theta - alpha*nabla_theta_L return theta In&nbsp;[7]: learned_theta = learn(X, Y, theta) Y_hat = learned_theta[0]*X**2 + learned_theta[1]*X + learned_theta[2] In&nbsp;[8]: plot(X, Y, Y_hat) Tensorflow and Autodifferentiation&#182;It can be extremely cumbersome to manually compute the derivative of our functions. It becomes much more complex when our functions are highly composed, where we combine the results of many intermediate calculations to produce our result. Instead, we can rely on libraries that provide autodifferentiation. There are many approaches to autodifferentiation, with the notion of a &#39;gradient tape&#39; being used in tensorflow 2 and pytorch. Most guides, resources and open-source implementations that you will find today are built using tensorflow, a python library that allows us to define complex computation graphs with built-in differentiation. Tensorflow is preferred for many reasons (though the gap may be closing), but using computation graphs can feel weird to a new user. Tensorflow has extensive documentation that I suggest you spend some time reading, since my goal is not to reproduce the tensorflow guide here. I assume you have a basic understanding of how tensorflow works. Let us first demonstrate the above regression problem using tensorflow before moving into more complex territory. In&nbsp;[9]: N = 50 a, b, c = 2, -1, 4 X = np.linspace(-1, 1, N) Y = a*X**2 + b*X + c + np.random.randn(N)*0.1 In&nbsp;[10]: X_ph = tf.placeholder(shape=(50,), dtype=tf.float32) # a placeholder for values, that we will later feed X into theta = tf.get_variable(&quot;theta&quot;, initializer=tf.random_normal(shape=(3,))) # our parameters Y_hat = theta[0]*(X_ph**2) + theta[1]*X_ph + theta[2] # our prediction WARNING:tensorflow:From /anaconda3/envs/rl-lessons/lib/python3.6/site-packages/tensorflow/python/framework/op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version. Instructions for updating: Colocations handled automatically by placer. In&nbsp;[11]: sess = tf.Session() # used to give tensors in the computation graph values sess.run(tf.global_variables_initializer()) # initialize defined ops and variables Y_hat_run = sess.run(Y_hat, feed_dict = { X_ph: X }) # get initial predictions In&nbsp;[12]: plot(X, Y, Y_hat_run) In&nbsp;[13]: L_theta = tf.reduce_mean((Y - Y_hat)**2) # same loss as before alpha = 1e-1 # learning rate optimizer = tf.train.GradientDescentOptimizer(alpha).minimize(L_theta) # autodifferentiation! In&nbsp;[14]: epochs = 100 for e in range(epochs): sess.run(optimizer, feed_dict = { X_ph:X }) In&nbsp;[15]: Y_hat_run = sess.run(Y_hat, feed_dict = { X_ph: X }) In&nbsp;[16]: plot(X, Y, Y_hat_run)","@type":"BlogPosting","url":"http://localhost:4000/function-approximation/","headline":"Function Approximation","dateModified":"2019-05-21T00:00:00-04:00","datePublished":"2019-05-21T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/function-approximation/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <h1 id="project_title"> TF 2.0 for Reinforcement Learning </h1>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        
        <h4>
          <a href="http://localhost:4000">Home</a>
        </h4>
        
        
        
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr />
<h1 id="Function-Approximation-in-Tensorflow">Function Approximation in Tensorflow<a class="anchor-link" href="#Function-Approximation-in-Tensorflow">&#182;</a></h1><p>Function approximation is a technique for <strong>learning</strong> a function $y$ by providing an approximation for the function, $\hat{y}$. A <strong>differentiable function approximator</strong> is a function whose output is a differentiable function of its inputs. There are many differentiable function approximators. You have have heard of linear regressions and logistic regressions. We can abstractly define a function approximator as a set of parameters $\theta$. For example, in a simple quadratic regression of the form
$$
\hat{y} = a x^2 + b x + c
$$
we would have $\theta = \left[ a, b, c \right]$.</p>
<hr />
<h3 id="Gradient-Descent-and-Loss-Functions">Gradient Descent and Loss Functions<a class="anchor-link" href="#Gradient-Descent-and-Loss-Functions">&#182;</a></h3><p>When a function approximator is differentiable, we have an additional tool at our disposal: <strong>gradient descent</strong>. Gradient descent is a tool for optimizing any differentiable function. The <strong>gradient</strong> of a function $f$ with respect to some parameters $\theta$ is denoted $\nabla_\theta f$, and is a vector of partial derivatives of $f$ with respect to each variable in $\theta$. For example, $\nabla_\theta \hat{y}$ would be
$$
\nabla_\theta \hat{y} = 
\begin{bmatrix}
x^2 \\
x \\
1
\end{bmatrix}
$$</p>
<p>Imagine some dataset $(X, Y)$ that we are interested in modelling, and we have a suspicion that the relationship between $X$ and $Y$ is quadratic. Then we can use a function like the one described above ($ax^2 + bx + c$) to try to model the dataset.</p>
<p>Given a data point $(x, y)$, we want the difference between our functions output $\hat{y}$ and the true value $y$ to be small. We use the <em>squared-error</em> to measure this difference: $\left(y - \hat{y} \right)^2$. If our function approximator $\theta$ <em>minimizes</em> the average squared error over all data points, then we say our function successfully models the data.</p>
<p>We define a <strong>loss function</strong> with respect to the model parameters $\theta$ that we want to minimize. In accordance with our description above, we get:
$$
L(\theta) = \frac{1}{N} \sum_{(x, y) \in X \times Y} \left(\hat{y} - y \right)^2
$$
where $N$ is the size of the dataset and $\hat{y} = ax^2 + bx + c $.</p>
<p>We can iteratively modify our paramaters $\theta$ so as to minimize this loss function. If we take the gradient of the loss function with respect to $\theta$ and we subtract that from $\theta$, then we get new values for $\theta$ such that the value $L(\theta)$ is smaller. This gives us <strong>gradient descent</strong>:
$$
\theta \gets \theta + \alpha \nabla_\theta L(\theta)
$$
where $\alpha$ is a factor called the <strong>learning rate</strong> that determines how much we change the network parameters with each application of gradient descent. We perform gradient descent for a given number of <strong>epochs</strong> until we are satisfied that our function does a good approximation.</p>
<p>In this case, we can easily analytically compute this:
$$
\nabla_\theta L(\theta) = \frac{1}{N} \sum_{(x, y) \in (X, Y)} 2(\hat{y} - y) \nabla_{\theta} \hat{y}
$$</p>
<p>where $\nabla_\theta \hat{y}$ is as descibed above.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">gym</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Y_hat</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;X&quot;</span><span class="p">:</span><span class="n">X</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span><span class="n">Y</span><span class="p">,</span> <span class="s2">&quot;Y_hat&quot;</span><span class="p">:</span><span class="n">Y_hat</span><span class="p">})</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;Y_hat&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># a, b, c estimates</span>
<span class="n">Y_hat</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Y_hat</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
" />
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[17]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">learn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="n">Y_hat</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nabla_theta_y_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">X</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="p">])</span>
        <span class="n">nabla_theta_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Y_hat</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">nabla_theta_y_hat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">nabla_theta_L</span>
    <span class="k">return</span> <span class="n">theta</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learned_theta</span> <span class="o">=</span> <span class="n">learn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
<span class="n">Y_hat</span> <span class="o">=</span> <span class="n">learned_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">learned_theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">learned_theta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Y_hat</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
" />
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr />
<h3 id="Tensorflow-and-Autodifferentiation">Tensorflow and Autodifferentiation<a class="anchor-link" href="#Tensorflow-and-Autodifferentiation">&#182;</a></h3><p>It can be extremely cumbersome to manually compute the derivative of our functions. It becomes much more complex when our functions are highly composed, where we combine the results of many intermediate calculations to produce our result. Instead, we can rely on libraries that provide <strong>autodifferentiation</strong>. There are many approaches to autodifferentiation, with the notion of a 'gradient tape' being used in <a href="https://www.tensorflow.org/alpha"><code>tensorflow 2</code></a> and <a href="https://pytorch.org/"><code>pytorch</code></a>. Most guides, resources and open-source implementations that you will find today are built using <code>tensorflow</code>, a python library that allows us to define complex <strong>computation graphs</strong> with built-in differentiation. Tensorflow is preferred for many reasons (though the gap may be closing), but using computation graphs can feel weird to a new user.</p>
<p>Tensorflow has <a href="https://www.tensorflow.org/guide/low_level_intro">extensive documentation</a> that I suggest you spend some time reading, since my goal is not to reproduce the tensorflow guide here. I assume you have a basic understanding of how tensorflow works.</p>
<p>Let us first demonstrate the above regression problem using tensorflow before moving into more complex territory.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">X</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X_ph</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># a placeholder for values, that we will later feed X into</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">random_normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,)))</span> <span class="c1"># our parameters</span>
<span class="n">Y_hat</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">X_ph</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">X_ph</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># our prediction</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>WARNING:tensorflow:From /anaconda3/envs/rl-lessons/lib/python3.6/site-packages/tensorflow/python/framework/op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.
Instructions for updating:
Colocations handled automatically by placer.
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">sess</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span> <span class="c1"># used to give tensors in the computation graph values</span>
<span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">global_variables_initializer</span><span class="p">())</span> <span class="c1"># initialize defined ops and variables</span>

<span class="n">Y_hat_run</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">Y_hat</span><span class="p">,</span> 
                    <span class="n">feed_dict</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">X_ph</span><span class="p">:</span> <span class="n">X</span>
                    <span class="p">})</span> <span class="c1"># get initial predictions</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Y_hat_run</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYAAAAEPCAYAAABLIROyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4zLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvnQurowAAIABJREFUeJzt3XeYXHd97/H3mZnts71Isnr92ZYty7JlX1uKjME2T0IScELgJiShhOJr4BoSJ08M5oHQnAccctMMIcRxLimGJNcOYCAEG3BvQnKRrZ+KJUuWVVarXW0vU+4fZ2Y1Ws2ZndmdM/Xzep59Vjp7Zs93z87+vufXnXg8joiIVJ9AsQMQEZHiUAIQEalSSgAiIlVKCUBEpEopAYiIVCklABGRKqUEICJSpZQARESqlBKAiEiVUgIQEalSSgAiIlUqVOwA0qgDNgNHgWiRYxERKRdBYBHwDDCRzQtKMQFsBh4pdhAiImXqF4BHszmxFBPAUYD+/hFisdxXKu3sDNPXN5z3oOZLceVGceVGceWmEuMKBBza25sgUYZmw7cEYIx5P/CRlEMrgW9aaz/i8ZKkKEAsFp9TAki+thQprtwortwortxUcFxZN537lgCstd8AvgFgjFkP3A98xq/riYhIbgo1CuirwCestScLdD0REZmF4/eOYMaY64A7rLWbs3zJCuCAfxGJiFS0lcDBbE4sRCfwh4Cv5Pqivr7hObWFdXc309s7lPPr/Ka4cqO4cqO4clOJcQUCDp2d4dxeM6crZckYUwtcA3zHz+sABIMB4sEAJ/pHiQcDBIOa4yYikonfNYANwB5r7YifFwkGA/SPTvHFe57mRP8YPe0NfOI9V9DeWEM0GvPz0iIiZcvvx+RVwGs+X4MITBf+ACf6x/jiPU8T8fvCIiJlzNcagLX228C3/bwGQDQWny78k070jxGNxUtyppuISCmoiIbyYMChp73hrGM97Q0EA06RIhIRKX0VkQBCwCfec8V0Ekj2AejpX0TEW0WUkdFojPbGGu64eQs4DsTdph91AIuIeKuIGgC4hb0TjdHT3ogTjZ1V+CeHiEYcR0NERUQSKqIGkImGiIqIpFfxj8IaIioikl7FJ4BMQ0RFRKpZxSeATENE1TcgItWs4ks8ryGitUGH/tEpbrvrMT54x4Pcdtdj9I9OKQmISNWo+E7g1CGi0VicYMAhBExG42n7Bu64eQuaPiYi1aDiEwAkhoiS+GGjcaJA1HE8+wbqggEicFbCiEZjBD2Oi4iUo6pIAOkk+wZSk0BPewO1NQH6hybPGTba2VxLX5rjGk4qIuWqahu8vfoGYtH0w0YnPY5rOKmIlKuqrQF49Q1MxGIeTUNex7XiqIiUp6qtAcCZ5SNC8fj08hHew0YDWnFURCpKVSeAdLyHjWrFURGpLCq/ZvBqGpqajKY9rg5gESlXSgBppBs2mum4iEg5UhOQiEiVUgIQEalSSgB5oEXlRKQcqQ9gnrThjIiUKz2qzpM2nBGRcuVrDcAY8yvAp4Em4EfW2lv8vF4xZNpwRtUrESllvtUAjDGrgK8BbwM2AJuMMb/o1/WKJdOGMyIipczPJqAbgW9Za1+z1k4B7wSe8vF6ReE1czj59J/sID7RP6oOYhEpKX62UqwBJo0x3wGWAd8DPuXj9YrCa+Zwcv8AdRCLSKly4nF/Nkc3xvwdcDXwBmAY+A7wz9bae2Z56QrggC9BFVj/0Di3/sXD5+w5cOct22hvri9iZCJSwVYCB7M50c8awDHgx9baXgBjzH3AFcA92by4r2+YWCz35NTd3Uxv71DOr/NDxGPXsfGJCL3jpRFjKd2vVIorN4orN5UYVyDg0NkZzuk1fiaA7wH/aIxpA4aAXwTu9/F6Jcdr17FgwIGoPzUvEZFs+dYjaa19CvgS8CjwEvAq8A9+Xa8UzdZBLCJSTL6WRdbau4G7/bxGKUvtIMZxIB7XEtIiUjI0JtFnyV3Hetobp3cdA60fJCLFp9aIItDwUBEpBXrsLAKtHyQipUAJoAgyrR8kIlIoSgBFoPWDRKQUKAEUQabhoeocFpFCUSdwEXitHwSoc1hECkaPl0WSHB4aisenh4eqc1hECkkJoISoc1hECkkJoISoc1hECkkJoIRo7SARKSSVLSVkts1lInDOcRGRuVICKDHRaAyHxC8mGieKlo4QEX+oCagMaHSQiPhBCaAMaHSQiPhBCaAMzHV0kGYVi0gmKhHKwFyWjkj2G9x212N88I4Hue2ux+gfnVISEJFp6gQuA3NZOsKr3+COm7egWQUiAqoBlI1cl45Qv4FI+UjW5E/0jxa0uVY1gDKWqZBP9hukfn263yCqJCBSKoo5zFs1gDKWqXNYs4pFykMxh3mrPChjyUJ+5pNDcpaw16xiESkdmWryfhfQSgBlbLZCPt2sYhEpLcVsrvU1ARhjfgL0AFOJQx+y1j7l5zWrjQp5kfKWsSZfgGv7whjjAOuA5dZarVogIpJGak0ex4F4vGDNtX52ApvE5x8ZY54zxnzEx2uJiJSt5DDvnvbG6WHeheBnAmgHHgRuBN4E3GSMud7H64mISA6ceLwwY8KNMR8HlllrPz7LqSuAA/5HJCJSkVYCB7M50c8+gK1AnbX2wcQhhzOdwbPq6xsmNodZq93dzfT2DuX8Or+VUlypm8vU14WIT0VLbnhoKd2vVIorN4orN/OJKxBw6OwM5/QaP0cBtQGfNcZcDdQA7wZu8vF6kgVtLiMiSb71AVhrvwc8AOwAtgN3W2uf8Ot6kp1Msw61fLRIdfF1HoC19lPAp/y8huTGa9YhDvSPpK8ZANqPWKQC6RGvynitH0TcSVsziAcd7SsgUqH0V1xlvBaJi8ViaWsGkWhcTUYiOSqXvw2tBVRlZq4flBwFFIG065HE5tBkpOYhqWblNNCiNNOS+Cp1c5n25nqi0Zj38tGBQE5NRsk1PzJtVVkOT0Yic1VOAy1UAxAg07aT8bQLVXk1GUVjceo8noA6m2vpG5osiycjkbmay0CLYr3/9fgl09JtO5maGL5+25u44+YttDfWEMiwGY3XE9BktHgbX4gUSq4DLYr5/lcCkFmlSwyZdhzz3uDCu9YgUmz5ap7JdaBFMd//agKSOcm0GU0wGPDY4MLruPYplsIJBgP0D40TcZyUpk4ydtymLp8y872e7ni6vw2vgRbFfP+rBiBzlq5mAN5PQLVB7VMsxZUcoXPrXzx81ryWKN7NM8nXzJwLU1Mb9Jwjk2utuVgKthpoDlYAB7QYXGH4FVeuT0yFimu+FFduSi2ueDDAbXc9ds5T+OdvupoP3vHgOed//bY3EQw4aV9zx81bue2uR9Mc34Lj0ak72/s/T4vBZb0aqGoA4guv2oHXcZFC8OqfyjSoIZ99WqX2/lcCEJGq4TVCJxR0PJtnvF4T9JgjEww4vv4M+aQEICVh5giMuTT/iczGqx3eicbTDnfO1HZfCX1a5RSrVKh0U+dvf9+VtNaHil5FlsqSHKFz5y3bGJ+InNMO75AoFKNxojNeM3NUz9Rk1HMkXLlQDUCKLt3Esc/f/ZQmiIkvotEY7c31ObXDV2qflhKAFJ13J5t3M1CprakipUfvkdmpCUiKLtnJlm6CTBDnnGFzkHnSju/xZjmUVYqnnFbkLCalRCm6dJ1st7/vSmo9NqPJNGnHb7FYXBvk+ChfT+2ZVuSUM1QDkKJL18nW1dbIyYHRtH/En7/pas8mI7/f0KdHJtLGdMfNWyifwX+lKZ9P7ZmaFVXonaHHFikJMzvTAhkm4GSatOO3qUjpLehVjtI96efzqd177L7SdKqsEoAx5py7Zoxpz384ImfMZdJOxu+Xh+aFmlD5T/4pNq+1dbx2n0sm11w2GSrFdXdKUbb3YzuwacaxR4CL8huOyBnJP+KZTQKpk3ay7YidS/NCus7e1qa6tDGFYHrcuGTm9aR/x81bMw4GyHWToXIfo18IGROAMeZBYDPQaIwZTPlSEHjGz8BEMi05Dekn7XjxLnTSt917JYy2NlSw5CAWixMPBs66VxOeO2al330uuZSyV9Lw/L1GYzm9R6rRbDWAG4EO4G7gvSnHI8DRbC5gjLkT6LLWvmcuAUp1i+bpjzjXTkGvAufOW7blLaa5KKchqMFggFePDfL5u586q0BvaaxN+6RP3Du5Rh0n5wXZ1Nwzu4z3yFo7CAwCb0w9nugTWAPszfR6Y8ybgHcDD8wvTJHspSsk4+S2GYdXwpiKxIo22idTM1YpisB04Q9nkuiXPrrVuxnNI7l6zxXRJkPzkW0n8IeMMYPGmKgxJor7u31kltd0AF8Avjj/MEWy49XBWJtjx7FXB3RNKPOfjJ+zT0t5bHu6n9sriU5Opd9nOlNNppIXZCumbO/THwPXA58Ebgd+BVgyy2v+NnH+0jlHJ5KjTG39ubTde3VAtzbV0Tc+lfY1fs8+ncuSGZnkqznJ6+f2auoJBpycm9EqeUG2Yso2AZyy1j5ljNkJLLDWfsEY85LXycaY9wOHrbUPGmPeM5fAEjvbzEl3d/OcX+snxZWbucR1on/Uo4PRoaO9Mafv1dYW585btjEViVETCtDaVEcg4HjG1T80zhfveSxtv0F3R1POP0u675+uQK2vc/+Mc7lfsVj8nPb52993JcsXthDIMKQ1FotzemTirHviTo479+f+yse2cfv7rjznGl1tjRmvUSiV9L6fq2wTwFRi3P9e4Argv3FHAnl5J7AokTA6gLAx5s+ttR/PNjBtCVkYFReXx4b0xOOe32+2J2EHiESi9I1PZYwr4tFROT4RoXd8/vc4GAykrZXEp9zn51x+vnTt85+/+6lZtzNM96TfVB9K+3OPjkdYvrDlnKfzvr7hed+L+aq49z1nbQmZtWwTwNeB7+E2/ew0xtwI7PY62Vp7ffLfiRrAG3Ip/EXmyqvpxmucfj6bbXJd1C7n5Q1mGRabrqCH9AvneRXa0VicOo+EOJfx+4GA487wBg3FLEFZ9VBZa+8GbrDWngKuAj6H+5QvUlJSC8lsOhjz2bHq3VGZflG7YKKzNJdOY6/1570WqfNaOC/gsZ1hbU36TvRMnbrJ8fvqiC0/Wf2OjDENwNuMMT0wPQruZuArs73WWnsPcM8c4xPJWS4djPlcNMzrCX0yGk9bCH/po1sZ8JjFCuRUY/BapM5r4TyvSVexqHcnulcNJ9P4fSlt2b7H/xV31M+LuEOqSfksUrYyNdvMZRx5uuTjNYkpMofE4FWoei1SF8ix0J7IMLGqLuDkPH5fSlu2CeAiYJ21VildKkqufQZz4ZVkvBY/80oMmZacTi5SN/MayYXzsi20gx6d6Mmhm3rSryzZJoDjQA0w4WMsIgVXiELNM8l4zGLNtCqm1x+s1yJ1uS6cN1tC1JN+ZZltMbjfT/zzGPBTY8z9wPQsGGvtrH0AIqXO70LNK8mAx+Jnc1jeIBBw8rJwnp7yq8tsNYCLE5+TawKdn/I19QGIZMkryeSUGMjcLJW3hfP0lF81ZlsM7r2Zvg5gjPlXa+1v5i8kkeqRS2LQU7jkWz6G6po8fA8RSaGncCkE7QksIlKllABERKqUEoCISJVSAhARqVIZE4Ax5rOJ7R8zKf7C3iIikrPZagBvBH5ijFmY4RytCioiUoZmSwDbgB8Dzxpjbkh3grV2T96jEhER3802ESwGfN4Y8wDwDWPMW4H9KV/XUhAiImUq24lgUSAGrAeSG6tqKQgRkTI222JwDvAJ4A+BT1pr/6YgUYmIiO9mqwE8jvvEv9Va+2IB4hERkQKZrRN4O3CFCn8RkcozWyfwRwoViIiIFJZmAouIVCklABGRKqUEICJSpZQARESqVD52BPNkjPks8HbcSWN/r5nDIiKlw7cagDHmGtzF5DYAlwMfNcZo+0gRkRLhWwKw1v4MuNZaGwF6cGsbI35dT0REcuPE4/4u6WOM+RPgVuDfgPdaa2e74ArggK9BiYhUrpXAwWxO9D0BABhjGoHvAt+y1n59ltNXAAf6+oaJxXKPrbu7md7eodyD9Jniyo3iyo3iyk0lxhUIOHR2hiGHBOBnH8D5xpiNANbaUeD/4fYHiIhICfBzFNAq4E+MMVtxRwG9Fbjbx+uJiEgO/OwE/j7wALADd1G5x6219/p1PRERyY2v8wCstZ8BPuPnNUREZG40E1hEpEopAYiIVCklABGRKqUEICJSpZQARESqlBKAiEiVUgIQEalSSgAiIlVKCUBEpEopAYiIVCklABGRKqUEICJSpZQARESqlBKAiEiVUgIQEalSSgAiIlVKCUBEpEopAYiIVCklABGRKlVRCWB8MsL23ceZmIoWOxQRkZLn66bwhbbvyGm+8q3naKoPseXiRVy7aTEL2huLHZaISEmqqASwfkUHX7x5C/c9tJcHt7/Gj545zEUrO7h202IuWd1FIOAUO0QRkZJRUQnAcRwuXt3FwpY6BoYneHjn6/x05xH+6j9eoLOljm0bF/MLGxbRFq4rdqgiIkXnawIwxnwaeEfivw9Ya//Iz+ulagvX8atbV/JLVy3nuX0neejnR7jv4Vf4zqMH2LimizdcupgLVrQTcFQrEJHq5FsCMMZcB9wAXArEgR8aY2601t7n1zXTCQUDXGZ6uMz0cPzUKD/b+TqPvnCU7Xt66W6r55qNi9ly8SJam2oLGZaISNH5WQM4CvyBtXYSwBjzMrDMx+vNakFHI+944xpu3LaK7XtO8NMdr/PvP93PfQ+/wsY1XWzbeB7rV3Sor0BEqoITj8d9v4gxZi3wGLDFWrt3ltNXAAd8Dyrh8PEhfvTUqzz07GEGRybpamvg+iuWcd0Vy+jRCCIRKT8rgYPZnOh7AjDGrAceAD5trf3HLF6yAjjQ1zdMLJZ7bN3dzfT2DuX8ukg0xs69J/nZc6/z0oFTAKxf2cHWDYu4dG0XNaFgzt8zH3H5TXHlRnHlRnHlZj5xBQIOnZ1hyCEB+N0JvAX4D+Bj1tp7/bzWfIWCAS4/v4fLz+/h5MAYjzx/lMdePMrX/nMXTfUhrrxwAVs3LGL5gmYcdRyLSAXwsxN4KXA/8E5r7UN+XccPXW0N3LhtFW/dupKXX+3n0ReO8vBzR3no50dY0t3E1osXceX6heo4FpGy5mcN4FagHviKMSZ57GvW2q/5eM28CgQc1q/sYP3KDkbGp3j6peM88vxR7n1oH9/+yX4uWtXBlosXsXFN57ybiERECs23BGCtvQW4xa/vX2hN9TVcu2kJ125awpHeYR7fdYwndx3nq/e/SGNdiCsu6OHqixaxenGLmohEpCxU1EzgQlncHeY33rCGX9+2mpdf7efxF4/y+K5j/HTn63S11vM/1i/kqvULWNTZVOxQRUQ8KQHMQ2oT0W9PRPj5nl6e3HWMB544yPceP8jyhc1cdeECrrhwAd3dzcUOV0TkLEoAedJQ565AuuXiRQwMT/D0yyd4Ytcx7n1oH9/6yT4uXt3FprVdbFrXTbihptjhiogoAfihLVzHDZuXcsPmpRztG+HJXcfZvqeXe36wm2/+l+WilR1cceECLl3bRX2tfgUiUhwqfXy2qLOJG7et4gO/toHtLx7lqZeP8/TLx3nuu33UhgJcvLqTzef3cMnqLupqNZJIRApHCaBAHMdh+cJmli9s5u1vWM3+I6d56qXjbLe9bLe9SgYiUnBKAEUQcBzWLmlj7ZI2fuu6dex9bYBndp/g2dRksKqTy0w3G1Z30VivX5OI5J9KliILBBzMsnbMsvbpZPD07hP8fE8v2/f0Ego6XLiig03rutm4touWRs0+FpH8UAIoIanJ4F3Xr+OVI4Ns33OC7baX5/f34fwQzNI2Nq7t5tK1XXS3NRQ7ZBEpY0oAJSrgOKxZ0sqaJa2849o1HD4xzLO2lx17e7n3wb3c++BelnSH2bSui0vXdrNsQVgzkEUkJ0oAZcBxHJYtaGbZgmZ+bdsqTvSPsmPvSXbsPcl3Hz/Idx47SEdLHZes7uKSNZ1csLxdaxOJyKyUAMpQT3sjb75iGW++YhmDo5M8v6+PHXt7efzFY/xkxxFqawJcuLyDS9Z0smF1F+3NdcUOWURKkBJAmWtprGXrhkVs3bCIqUgUe2iAnftO8ty+k+zcdxKwLFsQ5uJVnVy8qpPVi1sIBgLFDltESoASQAWpCQW5aFUnF63q5F3Xr+PIyRGe23eSF/b38YMnD/HAE6/SWBdi/coONqzu5KKVHVqjSKSKKQFUKMdxWNIdZkl3mLdctYLR8Sl2Heznhf19vPBKH8/sPgHAikUtnL+0jfWrOli3pFV9ByJVRAmgSjTW17D5/B42n99DLB7n8PFhXjzQx94jg/z3s4f54dOHqAkFMEvbWL+ygwuWt7OkJ0xAI4tEKpYSQBUKpCxL0d3dzOEj/dhDA+w6cIoXD5ziWw/tA6C5sYYLlrdz4Qo3IWjegUhlUQIQ6mtDXLKmi0vWdAFwanCcl1/t56WD/bz06imeftltLupqref85e2cv6yN85e109FSX8ywRWSelADkHB0t9dN7G8TjcY72jfLSwVO8/Go/O/b08ujzRwHoaWvAJJLBuqVtdLYqIYiUEyUAychxHM7rauK8riauu3wpsXic104Ms/vQAPZQP9ttL48kEkJnSz3rlraybmkb65a2sbCjUbOTRUqYEoDkJJAyK/mGzUuJxeIcPjHMntcG2Ht4gF0H+3li13HA7UNYs9hdzmLt4jaWLwxrlJFICVECkHkJBM50KF9/+VLi8TjH+8fYc3iAPYcH2HfkNDv2ngQgFHTPXbu4jVXntbB6catmKYsUkRKA5JXjOCzsaGRhRyPbLjkPgNMjk+w/cpp9R06z77XT/Hj7YSJPxwFob65j1Xkt7seiFlYsbNFmOCIF4nsCMMa0AI8Dv2ytPej39aT0tDbVsmldN5vWdQMwFYlx6MQQr7w+mPg4zXbbC4DjwHldTVywopOF7fWsWNjC0p4wNSEtXyGSb74mAGPMlcDfAev8vI6Ul5pQgNXntbL6vNbpY4Ojk7zy+iAHjw5y4OgQT790jMGRSQCCAXdW87IFYbe5aUEzS3rC1NWopiAyH37XAD4AfBj4ps/XkTLX0ljLxjVdbEzMRejqCrN7fy8Hjw5x4Nggrx4bYsfek9MjjhwHFnU2sWxBmKU9YZZ2h1nSE6a1qVYjj0Sy5GsCsNa+H8AY4+dlpAI5jkNXawNdrQ1cfn4PAPF4nFODExw6PsSrx4c4dHwYe2iAJxOjjsAdebSk200Ki7ubWNwV5ryuRupr1d0lMpMTj8d9v4gx5iDwhiz7AFYAB3wMRyrM0OgkB18f5MDR04nPgxw6OshkJDZ9Tk9HI8sXusNXly1sZkmP24zUWF9TxMhFfLESOJjNiSX7WNTXN0wslnty6u5uprd3yIeI5kdx5SbXuBa21rGwtYerErWFWCxO78AYr/WO8PrJYY6cHOFI7zA/332CaMr7qi1cy6LOJhZ1Nk6PXlrQ0UhnSz2BwLlNSZVyvwpFcc1uYjLK8f5RjveP0drSwLrz5rZEeyDg0NkZzuk1JZsAROYjEHBYkCjMLzPd08cj0Ri9A2Mc7RvlaN9I4vMoj794jPHJ6PR5oaBDd1sDC9obWdDRQE9bA91tDRjHwYnGCAU1KkmyNzoeoXdgbPrjeP8YJ/pHOXZqlIHhyenzWppqufPmqwv2/lICkKoSCgYST/xNwJnEEI/HGRyZ5Ngp90nseMrnXQdPMZXSnOQ40NFcT3dbfaKfop7O1nr3c0s97S112nWtyoxNROgbHKfv9Dh9g+OcPO3+++TpMU70jzEyHjnr/HBDDQs7Glm/ooOeZM2zvYH1a3sYGhwrWNwFSQDW2hWFuI7IXDmOQ2u4jtZwHWZZ+1lfi8XjnB6epHdgjPFonP2H+uk9PUZv/xgvHOjjdMoTnPu9oC1cR0dzHe0t9XQ0u//uaKmnLVxHW7iW1nCd5jaUgXg8zuhEhIHhSQaGJ+gfnKB/aJz+oQlODU1wKvH/mQV8KOjQ0VJPd2s9my9YQHdb/XQtsrutgYa69EVvfV2IQjZMqQYgMouA49DeXEd7cx3d3c1sWHF2gpiKRDk1OMHJwTNPff2DbgFx+MQwz+87eVaHdFJTfWg6IbQ01dHaVEtzUw0tjbW0NNXS0lhLc2MNzY01WkMpj+LxOCNjUxzvH2VoZIrTI5MMjU4yODLJYOJzssA/PTJ5Vu0vKdxQQ0dLHV2t9axd0kpnovaXrAm2NNWWxWZKSgAi81QTCk73N6QTj8cZGY9wanCcgeFJTg9PMDA8wcDIJANDbiFz7NQAg6PpCxuAupog4YYQ4YZawg0hmhpqaKqvobE+RGN9iAVdzcSmIjTUh2isC1FfG6S+1v1cVxssi8IoF5FojPHJKOOTEcYnooxPRhmdmGJ0PMLoRISR8Qhj4xFGJ6YYHoswPDY1/TEyNnXWQIBUTfUhmhtraQvXsmZxK63hWtrCde7npjo6WtwHgUpJyEoAIj5zHIdwQw3hhhqWLfA+Lx6PMz4ZZXB08qwn09TCK/nRe3rcLezGI8RmGcrtAHWJRFBXE6Q2FKSuNuB+rglSWxOgJhggFDr3cyjgEAg4BJMfwQABx8Fx3JoRjtvk5eAec38O92eJA+HwAIODY8TicaKxOLFYnGjU/Xc0FiMajTMVjTEViRGJuh9TEfdjMhJjYjLKZCTKxFSMyakoE1NuYe+VKFPVhgI01IcI17v3flFHI00Nbo1qQVcYJxabrmm1NLm1rWrr3FcCECkRjuPQUBeioS7EgvbZz4czSaOhqZ7Drw8wOj7F2GSU8YkI45NRxhJPyGOTkUQBeqYgnZyKMTw2xeRU1C14o/HpgjibAjZfAo5DTShAKOhMJ5+aUIDaGjdBNTXU0NGSSFw1AepTajgNtcHp/zfWhRI1ohoa60IZ+1hKaRhoMSkBiJSxZNLobm+ASGT2F2QpHk8+pbtP7LF4nGg0Nn0snjhn+mk/8RnHITl9IuA4dHQ20X9qJFGLCBA8p0bhaMRUESkBiMg5HMdxn8iDwDwmS3d3hakpwGoDMjdKvSIiVUoJQESkSikBiIhUKSUAEZEqpQQgIlKllABERKpUKQ4DDQJp12LP1nxe6yfFlRt9UC8oAAAHq0lEQVTFlRvFlZtKiyvldVmvU1GQHcFytBV4pNhBiIiUqV8AHs3mxFJMAHXAZuAoEJ3lXBERcQWBRcAzwEQ2LyjFBCAiIgWgTmARkSqlBCAiUqWUAEREqpQSgIhIlVICEBGpUkoAIiJVSglARKRKleJSEFkzxnwOiFprP5Pma7XA3wOXA2PAb1lrdxtjHODLwC8DMeAD1trH8hTPMuCfgB7AAu+y1g7POOc7wLLEf4PARbgT354D+oBXUk6/zFo778lwWca1HHgR2J84dNxa+2av+zjfmHKIaxHwD8BC3N/Xrdbah4wxNeT5fhljfgu4HXcPrP9jrf2bGV/fCHwDaAEeBm6y1kay+TnmI4u43gr8Ce7+7weA91pr+40x7wb+FDieOPUBa+0nCxjXp4H3Af2JQ39nrf0br/tYiLgS174n5fRuoN9ae5Hf9ytx/RbgceCXrbUHZ3yt4O+vsqwBGGNajTF/D/xBhtP+NzBirb0A+Bhnfum/DlwAXAi8DbjHGJOvRHgXcJe19nzgWeBTM0+w1v6qtXajtXYjcB/uH8WzwAbgieTXEh/5mgk9a1y4Bfy/pFz7zYnjXvexUHF9Gfhu4n79JvAvxpggeb5fxpjFwBdwlyLZCHzQGHPhjNP+CfiItXYdbmH7gRx+Dl/iShQoXwXeYq29BHge+Eziy5cDv59yf/JZ+Gdzvy4H/mfK9ZMFsdd99D0ua+3OlL+/q3GT000p8fpyvxKxXYm7RMM6j1MK/v4qywQAvBXYC/xZhnPeAvwzgLX2YaA7kUnfAtxrrY1Za/cAh3DfCPOSeCLdBvx74tA9wG9kON8A7wZuTRzanIjxWWPMk8aYa+YbU45xbQYuMsbsNMY8ZIy5OHHc6z4WKq77gH9J/HsfUA+Eyf/9ug54yFp7ylo7kojr7SnxLgcarLVPpsab6+8933HhPuV+2Fp7JPH/5zlTw9wMvNsY84Ix5p+MMe0FjAvcAvUTxpjnjTF/bYyp97qPBY4r6TbgZ9ba5Lo5ft4vcAv0DwOvz/xCsd5fZZkArLX/11r7p2ReK+g83PWEko4CSzIcn68uYDClKjvb9/0U8GVr7WDi/3HgfuAq4H8B3zLGdBUwrnHcJ5BNwJ3A/Ynmn6LeL2vtf1hrk00ItwI7rLWnyf/9mu3n9Pp6rr/3vMZlre2z1t4HYIxpAP4Y974kz/0cbm3pMPDXhYrLGBMGdgB/iPueasN9z/v1fsoqrpT4WoEP4jadpZ7r1/3CWvt+a63XQpdFeX+VdB+AMeY3gD+fcXi3tfa6LF4ewC0kkhzcNmSv4/ONa++M74vX9008WdwAvD95zFr7tymn7DDGPAVsAf6zEHHN6Ef5vjHmDtymsqLfr8T3+BjwIeCaRLzzvl8zzPZzZvt+ghzvzzzjAqYLtPuA56y1/whgrb0x5etf4kz/ju9xJdqofynl+n8G3A18P9Pr/I4rxW8D91trT6TE7Of9mk1R3l8lnQCstf8G/NscX/4a7sp4yV/iQtyqV/I4M47PK65kp6QxJphoi16U4fv+EvADa+14yut/B3jcWpuM1wGmChWXMeajuH0AfTOu73UfCxJX4twv4TZFbbPWvpY4Nu/7NcNruMvoJs38Ob3eNyeA1ix/737Elewo/y/gIeDjiWOtwPustcnE6wB562idLa5EM+F11tq7U66f+n5K+zq/40rxNuCLKfH6fb9mU5T3V1k2AWXp+8DvAhhjtgLj1tpDiePvMsYEjTFrcDtknpnvxay1U7j7GLwzceh3gR94nH4V5+55cAmJTu1E/8Clac7xM65rgN9LXP8a3BFKu/G+jwWJK/Hkfy2wJVn4J+T7fv0YeJMxptsY04g7WOCHKfG+CowbY7YkDv0ObhLP5fee97gSHeLfBb5trf2YtTb5tDgM/FGi4xHgI7g1hILEhTti7EvGmJWJkXcfBu7zuo8FjItEPJcBT6Qc9vt+ZVSs91dFJQBjzE3GmM8m/vtXQJ0xZhfwl7g3FNzOlF24nWX/CfyetXYsTyHcjDvq4CXcp5Db08QFsAo346f6LNBjjHkxEePvWmuHChjXLcD1ievfCfymtTaG9330Pa7EH+qncYe//TTRQb3TGHMeeb5fiU7UTwI/AXbi1oaeNsZ83xhzeeK0dwF/bozZjdsR/ZeZfo58yCKuX8VtY397yv35RuJp8R3AV40xL+MWeH9UqListb24TXbfxR266HBm0IbXffQ9rsRp3cBkag3c7/vlpdjvL+0HICJSpSqqBiAiItlTAhARqVJKACIiVUoJQESkSikBiIhUKSUAkQyMMZuMMadThuphjOkyxuw3xrylmLGJzJeGgYrMwhjzIdw1djYBQ8CPgAettV8oamAi86QEIJIFY8w3cSfn7MedyPfrKbNuRcqSEoBIFowxTbgzS2uAi2weN3wRKRb1AYhkxwDNuMsaX1bkWETyQjUAkVkk9hl4FncDkXrcVSQvtdYeK2pgIvOkBCCSQWK1zR8BL1lrP5o49g+4/QBvzOO2nSIFpyYgkcy+DDRx9v7THwY6SFlPXqQcqQYgIlKlVAMQEalSSgAiIlVKCUBEpEopAYiIVCklABGRKqUEICJSpZQARESqlBKAiEiV+v/x+aMMyrsJZgAAAABJRU5ErkJggg==
" />
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[13]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">L_theta</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">((</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y_hat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># same loss as before</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">1e-1</span> <span class="c1"># learning rate</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">train</span><span class="o">.</span><span class="n">GradientDescentOptimizer</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">L_theta</span><span class="p">)</span> <span class="c1"># autodifferentiation!</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[14]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">epochs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
    <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> 
            <span class="n">feed_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">X_ph</span><span class="p">:</span><span class="n">X</span>
            <span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">Y_hat_run</span> <span class="o">=</span> <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">Y_hat</span><span class="p">,</span> 
                    <span class="n">feed_dict</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">X_ph</span><span class="p">:</span> <span class="n">X</span>
                    <span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[16]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Y_hat_run</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

    <div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
" />
</div>

</div>

</div>
</div>

</div>


        
        <h4>
          <a href="http://localhost:4000">Home</a>
        </h4>
        
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p class="copyright">alexandervandekleut.github.io maintained by <a href="https://github.com/alexandervandekleut">alexandervandekleut</a></p>
        
      </footer>
    </div>

    
  </body>
</html>
